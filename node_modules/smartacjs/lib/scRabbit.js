/**
 * Copyright © 2015 Smartac Inc. All rights reserved.
 * Created by Simon on 2015/8/18.
 */
var amqp = require("amqplib");
var Promise = require("bluebird");
var domain = require('domain');
var uuid = require('node-uuid');
var scCommon=require('./scCommon');
var EventEmitter = require('events').EventEmitter;
var inherits = require('util').inherits;

exports.resetTotal=function()
{
    exports.messageInCount=0;
    exports.messageOutCount=0;
};
exports.resetTotal();
////////---------------连接对象
var _connIndex=0;
function Connection(url, name) {
    this.name = name ? name : "AMQP"+_connIndex++;
    this.log=scCommon.createNamedLog(undefined,this.name);
    // 当前URL
    this._url = url;
    this._urls = url.split(";");
    this._urlIndex = 0;
    // 当前是否运行中
    this._isRuning = false;
    // 连接对象
    this._conn = null;
    this._channel = null;
    // 预处理命令序列
    this._declare = new Array();
    // 队列映射
    this._queueList = new Array();
    // 发送缓冲
    this._cacheCommand = new Array();
    // RPCServer
    this._mapRPCServer={};
    // RPCClient
    this._mapRPCClient={};
    // 系统通知
    this._dom = domain.create();
    this._dom.add(amqp);
    var self=this;
    this._dom.on('error', function (err) {
        console.error("domain error:%s", err);
        self._reconnect();
    })
    this._dom.on('reject', function (err) {
        console.error("domain reject:%s", err);
    })
    this._dom.on('blocked', makeFunc (this,function (err) {
        console.error("domain blocked:%s", err);
    }));
    this._dom.on('unblocked', makeFunc (this,function (err) {
        console.error("domain unblocked:%s", err);
    }));
    this._dom.on('return', makeFunc (this,function (err) {
        console.error("domain return:%s", err);
    }));
    this._dom.on('drain', makeFunc (this,function (err) {
        console.error("domain drain:%s", err);
    }));
    this.log.info("created")
}
inherits(Connection, EventEmitter);
Connection.prototype.connectSuccess = function (conn) {
    this.log.info("%s connect '%s' success!", this.name, this.url);
    var self=this;
    // 连接成功,开始声明通道
    conn.createChannel().then(function (ch) {
            self._dom.add(conn);
            self._dom.add(ch);
            // 声明通道成功,保存连接和通道
            self._conn = conn;
            self._channel = ch;
            // 开始恢复声明
            var commandList = new Array();
            for (var i = 0; i < self._declare.length; i++) {
                commandList.push(self._declare[i].execute());
            }
            Promise.all(commandList).then(function () {
                // 执行积压命令
                self._executeCache();
                self.emit('connected');
            });
        }, function (err) {
            //声明通道失败
            conn.close();
            self._dom.remove(self._conn);
            self._dom.remove(self._channel);
            self.connectReject(err);
        }
    );
}

Connection.prototype.connectReject = function (err) {
    this.log.error("%s connect '%s' fail!error=%s", this.name, this.url, err);
    // 等待1秒
    var self = this;
    setTimeout(function () {
        // 换一个URL重试
        if (self._urlIndex < self._urls.length-1) {
            self._urlIndex++;
        }
        else {
            self._urlIndex = 0;
        }
        self.url=self._urls[self._urlIndex];
        if (self._isRuning && self._conn == null) {
            self._connect();
        }
    }, 1000);
}
Connection.prototype._connect = function () {
    var self = this;
    this._dom.run(function(){
        amqp.connect(self.url+"?heartbeat=5", {timeout:10000}).then(function (conn) {
                self.connectSuccess(conn);
            },
            function (err) {
                self.connectReject(err);
            }
        ).catch(function (err) {
                self.connectReject(err);
            }
        );
    });
}
// 启动
Connection.prototype.start = function () {
    this._isRuning = true;
    if (this._conn == null) {
        this.url=this._urls[this._urlIndex];
        this._connect();
    }
}
// 停止
Connection.prototype.stop = function () {
    if (this._isRuning && this._conn != null) {
        this._conn.close();
        this._conn = null;
    }
    this._isRuning = false;
}

// 关闭
Connection.prototype._close=function(){
    if (this._channel!=null) {
        try{
            this._channel.close();
            this._channel.close();
        }catch(e){}
    }
    this._channel = null;
    if (this._conn != null) {
        try{
            this._conn.close();
            this._conn.close();
        }catch(e){}

    }
    this._conn = null;
    this.emit('disconnected');

}
// 重新连接
Connection.prototype._reconnect=function(){
    this._close();
    // this._connect();
    this.connectReject('reconnect');
}
// 是否运行中
Connection.prototype.isRuning = function () {
    return this._isRuning;
}
// 是否已连接
Connection.prototype.isConnected = function () {
    return this._isRuning && this._conn != null && this._channel != null;
}
// 添加声明
Connection.prototype._addDeclare = function (cmd) {
    if (this._isDeclare(cmd.name)) return;
    this._declare.push(cmd);
}
// 移除声明
Connection.prototype._removeDeclare = function (name) {
    for (var i = 0; i < this._declare.length; i++) {
        if (this._declare[i].name == name) {
            this._declare.remove(i);
            return;
        }
    }
}
// 是否已经声明
Connection.prototype._isDeclare = function (name) {
    for (var i = 0; i < this._declare.length; i++) {
        if (this._declare[i].name == name) {
            return true;
        }
    }
    return false;
}
// 执行缓存
Connection.prototype._executeCache = function () {
    while (this._cacheCommand.length > 0) {
        var cmd = this._cacheCommand.shift();
        if (cmd.commandType == 'publishMessage') {
            if (!cmd.execute()) {
                // 执行失败?
                //this._cacheCommand.unshift(cmd);
                console.error('execute cache failed!');
            }
        }
        else cmd.execute();
    }
}

// 声明交换器
Connection.prototype.declareExchange = function (name, type, durable, autoDelete) {
    var declareName = "declare exchange '" + name + "'";
    durable = durable != undefined ? durable : true;
    autoDelete = autoDelete != undefined ? autoDelete : false;
    if (!this._isDeclare(declareName)) {
        var cmd = new Object();
        cmd.connection = this;
        cmd.commandType = "declareExchange";
        cmd.exchangeName = name;
        cmd.type = type;
        cmd.durable = durable;
        cmd.autoDelete = autoDelete;
        cmd.name = declareName;
        cmd.execute = function ()
        {
            return new Promise(function(resolve, reject)
            {
                if (cmd.connection.isConnected())
                {
                    // 执行指令
                    return cmd.connection._channel.assertExchange(cmd.exchangeName, cmd.type, {
                        durable: cmd.durable,
                        autoDelete: cmd.autoDelete
                    }).then(function () {
                        cmd.connection.log.info("success %s", cmd.name);
                        resolve();
                    }, function (err) {
                        cmd.connection.log.info("%s fail!error=%s", cmd.name, err);
                        reject(err);
                    }).then(null, makeFunc(this, function (err) {
                        cmd.connection.log.info("%s crash!error=%s", cmd.name, err);
                        reject(err);
                    }));
                }
                else {
                    cmd.connection.log.warn("%s fail,connection closed!", cmd.name);
                    reject("connection closed!");
                }
            });
        };
        // 添加声明
        this._addDeclare(cmd);
        // 如果已经连接,立即执行
        if (this.isConnected()) cmd.execute();
        this.log.info("declare exchange '%s'",name);
    }
    else
    {
        this.log.warn("exchange %s already declare!!",name);
    }
}
// 声明队列
Connection.prototype.declareQueue = function (name, onMessage, durable, autoDelete, exclusive, needAck) {
    var isRandom=name.indexOf("?")!=-1;
    // 处理名称字段，把？替换成guid
    name = name.replace("?", uuid.v1());
    name = name.replace(/\-/g, "");
    durable = durable != undefined ? durable : false;  //simon 2016.10.31 update
    autoDelete = autoDelete != undefined ? autoDelete : true;//simon 2016.10.31 update
    exclusive = exclusive != undefined ? exclusive : false;
    needAck = needAck != undefined ? needAck : false;
    var queue = this._queueList[name];
    if (isRandom && durable)
    {
        this.log.error("declare queue '%s' error! random queue is durable!",name);
        process.exit(109);
    }
    if (!queue) {
        // 创建对象
        queue = new Queue(this, name, onMessage, durable, autoDelete, exclusive, needAck);
        this._queueList[name] = queue;
        // 创建命令
        var cmd = new Object();
        cmd.connection = this;
        cmd.commandType = "declareQueue";
        cmd.queueName = name;
        cmd.durable = durable;
        cmd.autoDelete = autoDelete;
        cmd.exclusive = exclusive;
        cmd.name = "declare queue '" + name + "'";
        cmd.execute = function () {
            return new Promise(function (resolve, reject) {
                if (cmd.connection.isConnected()) {
                    // 执行指令
                    cmd.connection._channel.assertQueue(cmd.queueName, {
                        durable: cmd.durable,
                        autoDelete: cmd.autoDelete,
                        exclusive: cmd.exclusive
                    }).then(function () {
                        cmd.connection.log.info("success %s", cmd.name);
                        resolve();
                    }, function (err) {
                        cmd.connection.log.info("%s fail!error=%s", cmd.name, err);
                        reject(err);
                    }).then(null, function (err) {
                        cmd.connection.log.info("%s crash!error=%s", cmd.name, err);
                        reject(err);
                    });
                }
                else {
                    cmd.connection.log.warn("%s fail,connection closed!", cmd.name);
                    reject("connection closed!");
                }
            });
        }
        // 添加声明
        this._addDeclare(cmd);
        // 如果已经连接,立即执行
        if (this.isConnected()) cmd.execute();

        // 默认自动开始
        queue.startConsume();
        this.log.info("declare queue '%s'",name);
    }
    else
    {
        this.log.warn("queue[%s] already declare!!",name);
    }
    return queue;
}
// 发布消息
Connection.prototype.publishMessage = function (exchangeName, routeKey, message, options) {
    if (!!!message || message.length==0) return;
    var cmd = new Object();
    cmd.connection = this;
    cmd.commandType = "publishMessage";
    cmd.exchangeName = exchangeName;
    cmd.routeKey = routeKey;
    if (typeof(message) == "string") cmd.message = new Buffer(message);
    else cmd.message = message;
    cmd.options = options;
    cmd.name = "publish";// 发布消息特殊,不区分摘要
    cmd.execute = function () {
        // return new Promise(function(resolve, reject)
        // {
            try{
                //this.connection.log.log("exchange:%s,routeKey:%s,message:%s",this.exchangeName, this.routeKey, this.message.toString());
                //TODO:这里无法判断发送缓冲,需要进一步处理!!!!!
                exports.messageOutCount++;
                cmd.connection._channel.publish(cmd.exchangeName, cmd.routeKey, cmd.message, cmd.options);
                return true;
                //resolve();
            }
            catch(err){
                cmd.connection.log.error("publish error!error=%s",err);
                return false;
                // 发送出错，连接重建
                //this.connection._reconnect();
                //reject(err);
            }
        // })
    };
    if (this.isConnected()) {

        if (this._cacheCommand.length > 0) {
            // 正在缓冲数据
            this._cacheCommand.push(cmd);
        }
        else if (!cmd.execute())// 直接发送
        {
            // 发送流已满,开始缓冲数据
            this._cacheCommand.push(cmd);
        }
    }
    else {
        // 当前没有连接,直接进入缓冲
        this._cacheCommand.push(cmd);
    }
}
////////---------------队列对象
function Queue(connection, name, onMessage, durable, autoDelete, exclusive, needAck) {
    this._connection = connection;
    this._onMessage = onMessage;
    this.name = name;
    this.durable = durable;
    this.exclusive = exclusive;
    this.autoDelete = autoDelete;
    this.needAck = needAck;
    this._consumerTag = name+".consumerTag";//uuid.v1();
    this._isCusume=false;
}
// 声明绑定
Queue.prototype.declareBinding = function (exchangeName, routeKey) {
    var declareName="binding '" + exchangeName + "'->'" + this.name + "'(" + routeKey + ")";
    if (!this._connection._isDeclare(declareName))
    {
        var cmd = new Object();
        cmd.connection = this._connection;
        cmd.commandType = "declareBinding";
        cmd.queueName = this.name;
        cmd.exchangeName = exchangeName;
        cmd.routeKey = routeKey;
        cmd.name = declareName;
        cmd.execute = function () {
            return new Promise(function (resolve, reject) {
                if (cmd.connection.isConnected()) {
                    return cmd.connection._channel.bindQueue(cmd.queueName, cmd.exchangeName, cmd.routeKey).then(function () {
                        cmd.connection.log.info("success %s", cmd.name);
                        resolve();
                    },function (err) {
                        cmd.connection.log.info("%s fail!error=%s", cmd.name, err);
                        reject(err);
                    }).then(null, function (err) {
                        cmd.connection.log.info("%s crash!error=%s", cmd.name, err);
                        reject(err);
                    });
                }
                else {
                    cmd.connection.log.warn("%s fail,connection closed!", cmd.name);
                    reject("connection closed!");
                }
            });
        };
        // 添加声明
        this._connection._addDeclare(cmd);
        // 如果已经连接,立即执行
        if (this._connection.isConnected()) cmd.execute();
    }
    else
    {
        this._connection.log.warn("queue '%s binding '%s' by routeKey '%s' already declare!!",this.name,exchangeName,routeKey);
    }
}
// 开始接收
Queue.prototype.startConsume = function () {
    if (this._isCusume)
    {
        this._connection.log.warn("queue[%s] consume already start!",this.name);
        return ;
    }
    this._isCusume=true;
    var cmd = new Object();
    cmd.connection = this._connection;
    cmd.commandType = "startConsume";
    cmd.queueName = this.name;
    cmd.onMessage = this._onMessage;
    cmd.options = {
        noAck: !this.needAck,
        consumerTag: this._consumerTag
        //exclusive:true
    };
    cmd.name = "consume '" + this.name + "'"
    cmd.execute = function () {
        return new Promise(function (resolve, reject) {
            if (cmd.connection.isConnected()) {
                cmd.connection._channel.consume(cmd.queueName, function(msg) {exports.messageInCount++;cmd.onMessage(msg);}, cmd.options).then(function () {
                    cmd.connection.log.info("success %s", cmd.name);
                    resolve();
                }, function (err) {
                    cmd.connection.log.info("%s fail!error=%s", cmd.name, err);
                    reject(err);
                }).then(null, function (err) {
                    cmd.connection.log.info("%s crash!error=%s", cmd.name, err);
                    reject(err);
                });
            }
            else {
                cmd.connection.log.warn("%s fail,connection closed!", cmd.name);
                reject("connection closed!");
            }
        });
    };
    // 添加声明
    this._connection._addDeclare(cmd);
    // 如果已经连接,立即执行
    if (this._connection.isConnected()) cmd.execute();
}
// 停止接收
Queue.prototype.stopConsume = function () {
    if (!this._isCusume)
    {
        this._connection.warn("queue[%s] consume already stop!",this.name);
        return ;
    }
    this._isCusume=false;
    var cmd = new Object();
    cmd.connection = this._connection;
    cmd.commandType = "stopConsume";
    cmd.consumerTag = this._consumerTag;
    cmd.name = "cancel consume '" + this.name + "'";
    cmd.execute = function () {
        return new Promise(function (resolve, reject)
        {
            if (cmd.connection.isConnected()) {
                return cmd.connection._channel.cancel(cmd.consumerTag).then(function () {
                    cmd.connection.log.info("success %s", cmd.name);
                    resolve();
                }, function (err) {
                    cmd.connection.log.info("%s fail!error=%s", cmd.name, err);
                    reject(err);
                }).then(null, function (err) {
                    cmd.connection.log.info("%s crash!error=%s", cmd.name, err);
                    reject(err);
                });
            }
            else {
                cmd.connection.log.warn("%s fail,connection closed!", cmd.name);
                reject("connection closed!");
            }
        });
    };

    // 移除声明
    this._connection._removeDeclare("consume '" + this.name + "'");
    // 如果已经连接,立即执行
    if (this._connection.isConnected()) cmd.execute();
}
defaultExchange={
    direct:"amq.direct",
    fanout:"amq.fanout",
    topic:"amq.topic",
    head:"amq.head"
}
////////---------------RPC Server
function RPCServer(conn, name, onRequest) {
    this.connection = conn;
    this.name = name;
    this.log=scCommon.createNamedLog(undefined,"RPCS:"+name);
    this._queue = conn.declareQueue(name, makeFunc(this, function(req){
        // 收到请求，直接转给客户
        try{
            onRequest(this,req);
        }
        catch(e)
        {
            this.log.error("onRequest handle crash!error=%s",e);
        }
    }), false, true, false, false);
    this._queue.declareBinding(defaultExchange.direct,name);
}
RPCServer.prototype.sendResponse=function(req,res){
    return this.connection.publishMessage("amq.direct",req.properties.replyTo,res,{
        correlationId: req.properties.correlationId
    });
}
//// 全局定时器
var _rpcClientList=new Array();
var _globalTimer=null;
function _globalTimerProc(){
    try{
        for (var i=0;i<_rpcClientList.length;i++)
        {
            _rpcClientList[i]._check();
        }
    }
    catch(e)
    {
        console.error("AMQP global timer crash!error=%s",e);
    }
    _globalTimer=setTimeout(_globalTimerProc,1000);
}
////////---------------RPC Client
function RPCClient(conn, name) {
    this.connection = conn;
    this.name = name;
    this.log=scCommon.createNamedLog(undefined,"RPCC:"+name);
    // 请求字典
    //this._requestDict = new Array();
    this._requestDict = {};
    // 序列发生器
    this._seq = 0;
    var queueName = name + ".?"
    this._queue = conn.declareQueue(queueName, makeFunc(this, this._onMessage), false, true, false, false);
    this._queue.declareBinding(defaultExchange.direct,this._queue.name);
    this.timeout=10;
    // 初始化第一次调用
    if (!_globalTimer)
    {
        _globalTimer=setTimeout(_globalTimerProc,1000);
    }
    _rpcClientList.push(this);
    this.log.info("create rpc client '%s' in conn %s",name,conn.name);
}
// 检查超时回应
RPCClient.prototype._check=function(){
    var now=new Date();
    for (var k in this._requestDict){
        var req=this._requestDict[k];
        if (!this.connection.isConnected())
        {
            // 连接断开
            this.log.warn("remove request,disconnected!id=%s",k);
            delete this._requestDict[k];
            req.deferred.reject("disconnected!");
        }
        else if (req.outOfTime<now)
        {
            // 请求超时
            this.log.warn("remove request,timeout!id=%s",k);
            delete this._requestDict[k];
            req.deferred.reject("timeout");
        }
    }
}
// 处理收到的回应
RPCClient.prototype._onMessage = function (msg) {
    var req=this._requestDict[msg.properties.correlationId];
    if (req)
    {
        delete this._requestDict[msg.properties.correlationId];
        req.deferred.resolve(msg);
    }
    else{
        this.log.warn("recv bad message,cann't find correlationId!correlationId=%s",msg.properties.correlationId)
    }
}
// 发送RPC请求
RPCClient.prototype.sendRequest = function (request, messageId,timeout) {
    var self=this;
    return new Promise(function (resolve, reject) {
        var correlationId = self._seq++;
        var outOfTime = new Date();
        if (!!!timeout) timeout = self.timeout;
        outOfTime.setSeconds(outOfTime.getSeconds() + timeout);
        var req = {
            correlationId: correlationId,
            outOfTime: outOfTime,
            request: request,
            deferred: {
                resolve:resolve,
                reject:reject
            },
            mandatory: true
        };
        self._requestDict[req.correlationId] = req;
        var call=function()
        {
            if (req.outOfTime<new Date())
            {
                // 等待连接过程中超时,取消发送
                self.log.log("send rpc request fail!waiting connect timeout!");
                return ;
            }
            self.log.log("sending rpc request,seq=%d",correlationId);
            self.connection.publishMessage("amq.direct", self.name, request, {
                correlationId: correlationId.toString(),
                replyTo: self._queue.name,
                messageId: messageId
            });
        }
        // 如果连接没有建立,等待连接建立后发送请求
        if (self.connection.isConnected()) call();
        else
        {
            self.connection.once('connected',function(){
                call();
            });
        }
    });
}

exports.createConnect = function (url) {
    return new Connection(url);
}
exports.createRPCClient = function (conn,name) {
    if (conn)
    {
        if (conn._mapRPCClient[name])
        {
            conn.log.warn("rpc client '%s' declare repeat!",name);
            return conn._mapRPCClient[name];
        }
        var obj=new RPCClient(conn,name);
        conn._mapRPCClient[name]=obj;
        return obj;
    }
    return null;
}
exports.createRPCServer = function (conn,name,onRequest) {
    if (conn)
    {
        if (conn._mapRPCServer[name])
        {
            conn.log.warn("rpc server '%s' declare repeat!",name);
            return conn._mapRPCServer[name];
        }
        var obj=new RPCServer(conn,name,onRequest);
        conn._mapRPCServer[name]=obj;
        return obj;
    }
    return null;
}

////////---------------辅助
// 创建函数包装，
// makeFunc([thisArg],fun,arg1,arg2,arg3)
// thisArg可以不填，则不会使用this调用
// 调用时参数顺序为，定义时参数+调用时参数
function makeFunc() {
    var args = Array.prototype.slice.call(arguments);
    if (args.length > 1) {
        var thisArg = null;
        if (typeof(args[0]) == "object") thisArg = args.shift();
        if (typeof(args[0]) != "function") return new Error("miss function parameter");
        var func = args.shift();
        return function () {
            return func.apply(thisArg, args.concat(Array.prototype.slice.call(arguments)));
        };
    }
    return new Error("miss parameter");
}

//function A(name) {
//    this.name = name
//}
//A.prototype.hello = function (k, v) {
//    this.log.log("msg:%s=%s",k,v);
//}
//A.prototype.call = function () {
//    var fn = makeFunc(this, this.hello, "Key", "Value");
//    test(fn);
//}
//
//function test(fn) {
//    fn();
//}
//var aa = new A("test1");
//aa.call();